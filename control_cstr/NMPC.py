"""NMPC for two CSTRs in series with recycle (CSTRSeriesRecycle).

This script builds a do-mpc model matching `src/models/cstr_series.py`,
tracks outputs y = [CB2, T2] to steady-state references generated by
`control_cstr/setup.py`, runs a simulation, saves figures, and prints the
closed-loop objective value.
"""

from pathlib import Path
from typing import Dict, Tuple

import do_mpc
from casadi import SX
import matplotlib.pyplot as plt
import numpy as np
import joblib


# ----------------------------- IO utilities ---------------------------------

def load_sim_setup(sim_setup_path: Path) -> Dict:
    """Load simulation setup dictionary saved by `setup.py`.

    Parameters
    ----------
    sim_setup_path: Path
        Path to the `sim_setup.pkl` file.

    Returns
    -------
    Dict
        Simulation setup dictionary with keys like N, Qy, Qu, reference_ns, etc.
    """
    return joblib.load(sim_setup_path.as_posix())


def get_figures_dir(repo_root: Path) -> Path:
    """Return (and create) the `figures/` directory under repository root."""
    figures_dir = repo_root / "figures"
    figures_dir.mkdir(parents=True, exist_ok=True)
    return figures_dir


def as_float(value) -> float:
    """Return a native float extracted from scalars/arrays safely (no deprecation warnings)."""
    arr = np.asarray(value)
    if arr.size == 0:
        return float('nan')
    return arr.reshape(-1)[0].item()

def build_model() -> do_mpc.model.Model:
    """Build and return the continuous CSTRSeriesRecycle model for do-mpc."""
    model = do_mpc.model.Model('continuous')

    # ------------------ Parameters (match setup/model defaults) ------------------
    C_A_O = 97.35
    T_O = 298.0
    C_B_O = 0.0
    C_U_O = 0.0
    V1 = 1e-3
    V2 = 2e-3
    U1A1 = 0.461
    U2A2 = 0.732
    rho = 1.05e3
    cp = 3.766
    Rg = 8.3145e-3

    k1_0 = 1.0e5
    E1 = 45.0
    k2_0 = 9.8e9
    E2 = 70.0
    k3_0 = 5.0e4
    E3 = 55.0
    dH1 = 60.0
    dH2 = 40.0
    dH3 = 60.0

    # ------------------------------- States ------------------------------------
    CA1 = model.set_variable(var_type='_x', var_name='CA1')
    T1 = model.set_variable(var_type='_x', var_name='T1')
    CA2 = model.set_variable(var_type='_x', var_name='CA2')
    T2 = model.set_variable(var_type='_x', var_name='T2')
    CB1 = model.set_variable(var_type='_x', var_name='CB1')
    CB2 = model.set_variable(var_type='_x', var_name='CB2')
    CU1 = model.set_variable(var_type='_x', var_name='CU1')
    CU2 = model.set_variable(var_type='_x', var_name='CU2')

    # -------------------------------- Inputs -----------------------------------
    F = model.set_variable(var_type='_u', var_name='F')
    L = model.set_variable(var_type='_u', var_name='L')
    Tc1 = model.set_variable(var_type='_u', var_name='Tc1')
    Tc2 = model.set_variable(var_type='_u', var_name='Tc2')

    # ------------------------------- Kinetics ----------------------------------
    k1_T1 = k1_0 * SX.exp(-E1 / (Rg * T1))
    k1_T2 = k1_0 * SX.exp(-E1 / (Rg * T2))
    k2_T1 = k2_0 * SX.exp(-E2 / (Rg * T1))
    k2_T2 = k2_0 * SX.exp(-E2 / (Rg * T2))
    k3_T1 = k3_0 * SX.exp(-E3 / (Rg * T1))

    r1_1 = k1_T1 * (CA1 ** 2)
    r2_1 = k2_T1 * CA1
    r3_1 = k3_T1 * CA1 * CB1
    r1_2 = k1_T2 * (CA2 ** 2)
    r2_2 = k2_T2 * CA2

    # ------------------------------- Balances ----------------------------------
    dCA1dt = (C_A_O / V1) * F + (L / V1) * CA2 - ((F + L) / V1) * CA1 - 2.0 * r1_1 - r2_1 - r3_1
    dCB1dt = (C_B_O / V1) * F + (L / V1) * CB2 - ((F + L) / V1) * CB1 + r1_1 + r3_1
    dCU1dt = (C_U_O / V1) * F + (L / V1) * CU2 - ((F + L) / V1) * CU1 + r2_1
    dT1dt = (T_O / V1) * F + (L / V1) * T2 \
            - (U1A1 / (V1 * rho * cp)) * (T1 - Tc1) \
            - ((F + L) / V1) * T1 \
            + ((-dH1) * r1_1 + (-dH2) * r2_1 + (-dH3) * r3_1) / (rho * cp)

    dCA2dt = ((F + L) / V2) * (CA1 - CA2) - 2.0 * r1_2 - r2_2
    dCB2dt = ((F + L) / V2) * (CB1 - CB2) + r1_2
    dCU2dt = ((F + L) / V2) * (CU1 - CU2) + r2_2
    dT2dt = ((F + L) / V2) * (T1 - T2) \
            - (U2A2 / (V2 * rho * cp)) * (T2 - Tc2) \
            + ((-dH1) * r1_2 + (-dH2) * r2_2) / (rho * cp)

    model.set_rhs('CA1', dCA1dt)
    model.set_rhs('T1', dT1dt)
    model.set_rhs('CA2', dCA2dt)
    model.set_rhs('T2', dT2dt)
    model.set_rhs('CB1', dCB1dt)
    model.set_rhs('CB2', dCB2dt)
    model.set_rhs('CU1', dCU1dt)
    model.set_rhs('CU2', dCU2dt)

    model.setup()
    return model


def build_mpc(model: do_mpc.model.Model, loaded_setup: Dict, reference_column: np.ndarray, scaler, scalerU) -> do_mpc.controller.MPC:
    """Build the MPC controller with objective and constraints.

    Parameters
    ----------
    model: do_mpc.model.Model
        The process model.
    loaded_setup: Dict
        Simulation setup dict (contains N, Qy, Qu, etc.).
    reference_column: np.ndarray
        Reference vector for outputs (here full state, length 8) at current step (non-scaled domain).
    scaler: StandardScaler
        Scaler for state variables (to transform weight matrices).
    scalerU: StandardScaler
        Scaler for input variables (to transform weight matrices).
    """
    mpc = do_mpc.controller.MPC(model)

    mpc.set_param(
        n_horizon=int(loaded_setup["N"]),
        t_step=1.0,
        state_discretization='collocation',
        collocation_type='radau',
        collocation_deg=2,
        collocation_ni=2,
        store_full_solution=True,
        nlpsol_opts={
            'ipopt.print_level': 0,
            'ipopt.sb': 'yes',
            'print_time': 0,
        },
    )

    # Transform weight matrices from scaled to unscaled domain
    # For quadratic form: (y_scaled)^T Qy_scaled (y_scaled) = (y/std)^T Qy_scaled (y/std)
    # To get equivalent penalty in unscaled space: Qy_unscaled = Qy_scaled / std^2
    Qy_scaled = loaded_setup["Qy"]
    Qu_scaled = loaded_setup["Qu"]
    
    # Get standard deviations from scalers (for StandardScaler: scale_ attribute)
    std_y = scaler.scale_  # shape (8,)
    std_u = scalerU.scale_  # shape (4,)
    
    # Transform diagonal weight matrices
    Qy_unscaled = Qy_scaled / (std_y[:, None] * std_y[None, :])  # element-wise for diagonal
    Qu_unscaled = Qu_scaled / (std_u[:, None] * std_u[None, :])
    
    # Tracking objective in non-scaled domain for outputs y (all states)
    y_ref = reference_column

    # Outputs equal to states; build lterm with diagonal Qy_unscaled
    y_vars = [
        model.x['CA1'], model.x['T1'], model.x['CA2'], model.x['T2'],
        model.x['CB1'], model.x['CB2'], model.x['CU1'], model.x['CU2'],
    ]
    lterm = 0
    for i in range(8):
        lterm = lterm + Qy_unscaled[i, i] * (y_vars[i] - float(y_ref[i])) ** 2
    mterm = 0 * lterm
    mpc.set_objective(mterm=mterm, lterm=lterm)

    # Penalty on input moves (diagonal terms from Qu_unscaled)
    mpc.set_rterm(F=Qu_unscaled[0, 0], L=Qu_unscaled[1, 1], Tc1=Qu_unscaled[2, 2], Tc2=Qu_unscaled[3, 3])

    # Input constraints provided by setup are scaled; convert back to non-scaled for the plant model
    umin_scaled = np.asarray(loaded_setup["u_min"]).reshape(1, -1)
    umax_scaled = np.asarray(loaded_setup["u_max"]).reshape(1, -1)
    umin_ns = scalerU.inverse_transform(umin_scaled)[0]
    umax_ns = scalerU.inverse_transform(umax_scaled)[0]
    mpc.bounds['lower', '_u', 'F'] = float(umin_ns[0])
    mpc.bounds['upper', '_u', 'F'] = float(umax_ns[0])
    mpc.bounds['lower', '_u', 'L'] = float(umin_ns[1])
    mpc.bounds['upper', '_u', 'L'] = float(umax_ns[1])
    mpc.bounds['lower', '_u', 'Tc1'] = float(umin_ns[2])
    mpc.bounds['upper', '_u', 'Tc1'] = float(umax_ns[2])
    mpc.bounds['lower', '_u', 'Tc2'] = float(umin_ns[3])
    mpc.bounds['upper', '_u', 'Tc2'] = float(umax_ns[3])

    mpc.setup()
    return mpc


def build_simulator(model: do_mpc.model.Model) -> do_mpc.simulator.Simulator:
    """Build the do-mpc simulator."""
    simulator = do_mpc.simulator.Simulator(model)
    simulator.set_param(t_step=1)
    simulator.setup()
    return simulator


# ---------------------------- Simulation core -------------------------------

def run_closed_loop(
    model: do_mpc.model.Model,
    loaded_setup: Dict,
    scaler,
    scalerU,
) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """Run closed-loop simulation.

    Returns
    -------
    time_history: (T+1,)
    y_history: (2, T+1)  non-scaled outputs [CB2; T2]
    u_history: (4, T+1)  applied inputs [F; L; Tc1; Tc2]
    """
    simulator = build_simulator(model)
    mpc = build_mpc(model, loaded_setup, reference_column=loaded_setup["reference_ns"][:, 0], scaler=scaler, scalerU=scalerU)

    # Initialize state by simulating to steady-state using previous input
    u_prev = loaded_setup['u_previous_ns'].astype(float)

    # Simple numeric steady-state initializer (mirrors setup logic)
    def ode_np(x, u):
        C_A_O = 97.35; T_O = 298.0; C_B_O = 0.0; C_U_O = 0.0
        V1 = 1e-3; V2 = 2e-3; U1A1 = 0.461; U2A2 = 0.732; rho = 1.05e3; cp = 3.766; Rg = 8.3145e-3
        k1_0 = 1.0e5; E1 = 45.0; k2_0 = 9.8e9; E2 = 70.0; k3_0 = 5.0e4; E3 = 55.0
        dH1 = 60.0; dH2 = 40.0; dH3 = 60.0
        CA1, T1, CA2, T2s, CB1, CB2s, CU1, CU2 = x
        F, L, Tc1, Tc2 = u
        k1_T1 = k1_0 * np.exp(-E1 / (Rg * T1)); k1_T2 = k1_0 * np.exp(-E1 / (Rg * T2s))
        k2_T1 = k2_0 * np.exp(-E2 / (Rg * T1)); k2_T2 = k2_0 * np.exp(-E2 / (Rg * T2s))
        k3_T1 = k3_0 * np.exp(-E3 / (Rg * T1))
        r1_1 = k1_T1 * (CA1 ** 2); r2_1 = k2_T1 * CA1; r3_1 = k3_T1 * CA1 * CB1
        r1_2 = k1_T2 * (CA2 ** 2); r2_2 = k2_T2 * CA2
        dCA1dt = (C_A_O / V1) * F + (L / V1) * CA2 - ((F + L) / V1) * CA1 - 2.0 * r1_1 - r2_1 - r3_1
        dCB1dt = (C_B_O / V1) * F + (L / V1) * CB2s - ((F + L) / V1) * CB1 + r1_1 + r3_1
        dCU1dt = (C_U_O / V1) * F + (L / V1) * CU2 - ((F + L) / V1) * CU1 + r2_1
        dT1dt = (T_O / V1) * F + (L / V1) * T2s - (U1A1 / (V1 * rho * cp)) * (T1 - Tc1) - ((F + L) / V1) * T1 + ((-dH1) * r1_1 + (-dH2) * r2_1 + (-dH3) * r3_1) / (rho * cp)
        dCA2dt = ((F + L) / V2) * (CA1 - CA2) - 2.0 * r1_2 - r2_2
        dCB2dt = ((F + L) / V2) * (CB1 - CB2s) + r1_2
        dCU2dt = ((F + L) / V2) * (CU1 - CU2) + r2_2
        dT2dt = ((F + L) / V2) * (T1 - T2s) - (U2A2 / (V2 * rho * cp)) * (T2s - Tc2) + ((-dH1) * r1_2 + (-dH2) * r2_2) / (rho * cp)
        return np.array([dCA1dt, dT1dt, dCA2dt, dT2dt, dCB1dt, dCB2dt, dCU1dt, dCU2dt])

    x0 = np.array([97.35, 298.0, 97.35, 298.0, 0.0, 0.0, 0.0, 0.0], dtype=float)
    dt = 0.1
    for _ in range(int(5000 / dt)):
        dx = ode_np(x0, u_prev)
        if np.linalg.norm(dx) < 1e-8:
            break
        x0 = x0 + dt * dx
        x0[0] = max(x0[0], 0.0); x0[2] = max(x0[2], 0.0)
        x0[4] = max(x0[4], 0.0); x0[5] = max(x0[5], 0.0)
        x0[6] = max(x0[6], 0.0); x0[7] = max(x0[7], 0.0)

    mpc.x0 = x0
    mpc.u0 = u_prev
    simulator.x0 = x0
    mpc.set_initial_guess()

    n_steps = int(loaded_setup["sim_time"])

    time_history = [0]
    # initialize full-state output history (ny=8)
    y0_vec = np.array([
        as_float(x0[0]), as_float(x0[1]), as_float(x0[2]), as_float(x0[3]),
        as_float(x0[4]), as_float(x0[5]), as_float(x0[6]), as_float(x0[7]),
    ])
    y_history_list = [y0_vec]
    u_history = [u_prev.flatten().tolist()]

    for k in range(1, n_steps + 1):
        if k % 100 == 0 and k < n_steps:
            mpc = build_mpc(model, loaded_setup, reference_column=loaded_setup["reference_ns"][:, k], scaler=scaler, scalerU=scalerU)
            mpc.x0 = np.array([
                float(simulator.x0['CA1']), float(simulator.x0['T1']),
                float(simulator.x0['CA2']), float(simulator.x0['T2']),
                float(simulator.x0['CB1']), float(simulator.x0['CB2']),
                float(simulator.x0['CU1']), float(simulator.x0['CU2']),
            ])
            mpc.u0 = np.array(u_history[-1])
            mpc.set_initial_guess()

        # do-mpc expects numpy x0; simulator.x0 is a DMStruct mapping variable names
        x_vec = np.array([
            float(simulator.x0['CA1']), float(simulator.x0['T1']),
            float(simulator.x0['CA2']), float(simulator.x0['T2']),
            float(simulator.x0['CB1']), float(simulator.x0['CB2']),
            float(simulator.x0['CU1']), float(simulator.x0['CU2']),
        ])
        u0 = mpc.make_step(x_vec)
        y_next = simulator.make_step(u0)

        time_history.append(k)
        y_vec = np.array([
            as_float(simulator.x0['CA1']), as_float(simulator.x0['T1']),
            as_float(simulator.x0['CA2']), as_float(simulator.x0['T2']),
            as_float(simulator.x0['CB1']), as_float(simulator.x0['CB2']),
            as_float(simulator.x0['CU1']), as_float(simulator.x0['CU2']),
        ])
        y_history_list.append(y_vec)
        u_history.append(u0.flatten().tolist())
        x0 = y_next

    time_arr = np.asarray(time_history)
    y_arr = np.asarray(y_history_list).T
    u_arr = np.asarray(u_history).T
    return time_arr, y_arr, u_arr


# ------------------------------ Plotting ------------------------------------

def plot_states(figures_dir: Path, time_arr: np.ndarray, y_arr: np.ndarray, loaded_setup: Dict) -> None:
    """Plot and save a subset of states vs references (for readability)."""
    n_steps = time_arr[-1]
    fig = plt.figure(figsize=(12, 10))
    names = ['CA1','T1','CA2','T2','CB1','CB2','CU1','CU2']
    for i in range(8):
        plt.subplot(4, 2, i+1)
        plt.plot(y_arr[i, :], label=names[i])
        plt.plot(loaded_setup["reference_ns"][i, :n_steps+1], 'r--', label=f'{names[i]} ref')
        plt.xlabel('Time step')
        plt.ylabel(names[i])
        plt.grid(True)
        if i == 1:
            plt.title('NMPC Simulation (states vs references)')
        if i in (0,1):
            plt.legend()
    plt.tight_layout()
    fig.savefig(figures_dir / 'NMPC_states.png', dpi=200)


def plot_inputs(figures_dir: Path, time_arr: np.ndarray, u_arr: np.ndarray) -> None:
    """Plot and save input trajectories."""
    fig, axs = plt.subplots(4, 1, figsize=(12, 10), sharex=True)
    input_names = ['F', 'L', 'Tc1', 'Tc2']
    for i in range(4):
        axs[i].plot(u_arr[i, :], label=input_names[i])
        axs[i].set_ylabel(input_names[i])
        axs[i].legend()
        axs[i].grid(True)
    axs[-1].set_xlabel('Time step')
    plt.tight_layout()
    fig.savefig(figures_dir / 'NMPC_inputs.png', dpi=200)


# ----------------------------- Evaluation -----------------------------------

def compute_closed_loop_objective(
    y_history: np.ndarray,
    u_history: np.ndarray,
    loaded_setup: Dict,
    data_dir: Path,
) -> float:
    """Compute the closed-loop objective in scaled space (like two-tank NMPC)."""
    scaler = joblib.load((data_dir / 'scaler.pkl').as_posix())
    scalerU = joblib.load((data_dir / 'scalerU.pkl').as_posix())

    y_sim = scaler.transform(y_history.T).T
    u_sim = scalerU.transform(u_history.T).T

    Qy = loaded_setup["Qy"]
    Qu = loaded_setup["Qu"]

    n_steps = min(500, y_history.shape[1])
    objective_value = 0.0
    y_term = 0.0
    u_term = 0.0
    for k in range(n_steps):
        y_diff = y_sim[:, k] - loaded_setup["reference"][:, k]
        prev_u = u_sim[:, k - 1] if k > 0 else u_sim[:, k]
        u_diff = u_sim[:, k] - prev_u
        y_term += float(y_diff.T @ Qy @ y_diff)
        u_term += float(u_diff.T @ Qu @ u_diff)
        print(f"u_diff: {u_diff}, u_term: {u_term}")
        objective_value = y_term + u_term
    return objective_value, y_term, u_term


# --------------------------------- Main -------------------------------------

def main() -> None:
    repo_root = Path(__file__).resolve().parent.parent
    # Prefer control_cstr setup
    sim_setup_path = repo_root / 'control_cstr' / 'sim_setup.pkl'
    if not sim_setup_path.exists():
        # Fallbacks
        alt1 = repo_root / 'control' / 'sim_setup.pkl'
        alt2 = repo_root / 'control_python' / 'sim_setup.pkl'
        if alt1.exists():
            sim_setup_path = alt1
        elif alt2.exists():
            sim_setup_path = alt2
        else:
            sim_setup_path = Path('sim_setup.pkl')

    loaded_setup = load_sim_setup(sim_setup_path)

    # Load scalers (for bounds conversion and evaluation)
    data_dir = repo_root / 'data'
    scaler = joblib.load((data_dir / 'scaler.pkl').as_posix())
    scalerU = joblib.load((data_dir / 'scalerU.pkl').as_posix())

    model = build_model()
    time_arr, y_arr, u_arr = run_closed_loop(model, loaded_setup, scaler, scalerU)

    figures_dir = get_figures_dir(repo_root)
    plot_states(figures_dir, time_arr, y_arr, loaded_setup)
    plot_inputs(figures_dir, time_arr, u_arr)

    objective_value, y_term, u_term = compute_closed_loop_objective(y_arr, u_arr, loaded_setup, data_dir)
    print(f"Closed-loop objective function value: {objective_value}")
    # print u and y terms
    print(f"  - State tracking term: {y_term}")
    print(f"  - Input increment term: {u_term}")
    
    # Save control loop data for comparison
    results_dir = repo_root / 'control_cstr'
    results_data = {
        'time': time_arr,
        'states': y_arr,  # shape (8, T+1) - non-scaled
        'inputs': u_arr,  # shape (4, T+1) - non-scaled
        'objective': objective_value,
        'state_term': y_term,
        'input_term': u_term,
        'reference_ns': loaded_setup.get('reference_ns'),
    }
    joblib.dump(results_data, (results_dir / 'NMPC_results.pkl').as_posix())
    print(f"Saved control loop data to {results_dir / 'NMPC_results.pkl'}")


if __name__ == "__main__":
    main()

